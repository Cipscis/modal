{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://modal/./node_modules/@cipscis/keybinding/dist/KeyBind.js","webpack://modal/./node_modules/@cipscis/keybinding/dist/KeyPress.js","webpack://modal/./node_modules/@cipscis/keybinding/dist/keybinding.js","webpack://modal/./src/focus-helpers.ts","webpack://modal/./src/trap-focus.ts","webpack://modal/./src/modal.ts","webpack://modal/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["class KeyBind extends Array {\r\n    /**\r\n     * Creates a special KeyBind array based on a string representation of a\r\n     *   key, key combination, or key sequence.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {string} bindingString - A string representing a key, key combination, or key sequence. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n     */\r\n    constructor(bindingString) {\r\n        if (!(typeof bindingString === 'string')) {\r\n            throw new RangeError(`KeyBind: Constructor argument must be a string`);\r\n        }\r\n        super(0);\r\n        const bindings = bindingString.trim().split(/\\s+/g);\r\n        for (const binding of bindings) {\r\n            this.push(binding);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a string representation of a KeyBind.\r\n     *\r\n     * @return {string}\r\n     */\r\n    toString() {\r\n        return this.join(' ');\r\n    }\r\n    /**\r\n     * Checks whether or not a given set of KeyPresses matches the current\r\n     *   KeyBind's criteria.\r\n     *\r\n     * @param  {KeyPress[]} keyPresses - The KeyPresses to check against.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    match(keyPresses) {\r\n        if (keyPresses.length !== this.length) {\r\n            return false;\r\n        }\r\n        for (const [i, keyPress] of keyPresses.entries()) {\r\n            const keyBind = this[i];\r\n            if (!keyPress.match(keyBind)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport { KeyBind };\r\n//# sourceMappingURL=KeyBind.js.map","const Patterns = Object.freeze({\r\n    alt: /\\balt\\+/g,\r\n    ctrl: /\\b(control|ctrl|command|cmd|meta)\\+/g,\r\n    shift: /\\bshift\\+/g,\r\n});\r\nconst Aliases = new Map([\r\n    ['space', ' '],\r\n    ['spacebar', ' '],\r\n    ['up', 'arrowup'],\r\n    ['right', 'arrowright'],\r\n    ['down', 'arrowdown'],\r\n    ['left', 'arrowleft'],\r\n    ['esc', 'escape'],\r\n]);\r\n;\r\nclass KeyPress {\r\n    key;\r\n    modifiers;\r\n    /**\r\n     * Creates a recording of a key press, including any modifier keys that were\r\n     *   pressed at the time.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {Object} options - Can accept a KeyboardEvent.\r\n     * @param {string} options.key - The key that was pressed.\r\n     * @param {boolean?} altKey - Whether or not the Alt key was pressed.\r\n     * @param {boolean?} metaKey - Whether or not the Meta key was pressed.\r\n     * @param {boolean?} ctrlKey - Whether or not the Ctrl key was pressed.\r\n     * @param {boolean?} shiftKey - Whether or not the Shift key was pressed.\r\n     */\r\n    constructor(options) {\r\n        if (!('key' in options)) {\r\n            throw new RangeError(`KeyPress: key is a required option`);\r\n        }\r\n        this.key = options.key;\r\n        this.modifiers = {\r\n            altKey: options.altKey || false,\r\n            ctrlKey: options.metaKey || options.ctrlKey || false,\r\n            shiftKey: options.shiftKey || false,\r\n        };\r\n    }\r\n    /**\r\n     * Checks whether or not a given string representing a key or a key\r\n     *   combination matches the current recorded KeyPress.\r\n     *\r\n     * @param  {string} keyString A string representing a key or key\r\n     *   combination. For example, 'esc' or 'Ctrl+G'.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    match(keyString) {\r\n        const requiredModifiers = {\r\n            altKey: false,\r\n            ctrlKey: false,\r\n            shiftKey: false,\r\n        };\r\n        // Gather required modifiers for keyString\r\n        if (Patterns.alt.test(keyString)) {\r\n            requiredModifiers.altKey = true;\r\n            keyString = keyString.replace(Patterns.alt, '');\r\n        }\r\n        if (Patterns.ctrl.test(keyString)) {\r\n            requiredModifiers.ctrlKey = true;\r\n            keyString = keyString.replace(Patterns.ctrl, '');\r\n        }\r\n        if (Patterns.shift.test(keyString)) {\r\n            requiredModifiers.shiftKey = true;\r\n            keyString = keyString.replace(Patterns.shift, '');\r\n        }\r\n        // Check if all keyString's required modifiers were met\r\n        let modifier;\r\n        for (modifier in requiredModifiers) {\r\n            if (requiredModifiers[modifier] && !this.modifiers[modifier]) {\r\n                // The modifier was required but not recorded\r\n                return false;\r\n            }\r\n        }\r\n        // Check if they keyString's key matches the key pressed\r\n        if (keyString.toLowerCase() === this.key.toLowerCase()) {\r\n            return true;\r\n        }\r\n        // Check if the keyString is an alias for a matching key\r\n        if (Aliases.get(keyString.toLowerCase()) === this.key.toLowerCase()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexport { KeyPress };\r\n//# sourceMappingURL=KeyPress.js.map","import { KeyBind } from './KeyBind.js';\r\nimport { KeyPress } from './KeyPress.js';\r\nconst bindings = new Map();\r\nconst defaults = Object.freeze({\r\n    allowInInput: false,\r\n});\r\n/**\r\n * Creates a wrapper for a callback function, which handles recording and\r\n *   checking keypresses so it can be bound directly to the 'keydown' event and\r\n *   decide when the callback should be invoked.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination,\r\n *   or key sequence the callback should to be bound to. For example, 'esc' or\r\n *   'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be bound.\r\n * @param {Object} options - Options to configure behaviour of the key binding.\r\n * @param {boolean} options.allowInInput - If set to true, the key binding will remain active while keyboard focus is in an element that can receive keyboard input, such as <input type=\"text\">.\r\n *\r\n * @return {function}\r\n */\r\nconst createFnWrapper = (keyString, fn, opts) => {\r\n    const options = Object.assign({}, defaults, opts);\r\n    const keyBind = new KeyBind(keyString);\r\n    const keyLog = [];\r\n    const fnWrapper = function (e, ...otherArgs) {\r\n        // Ignore modifier keys\r\n        if (['Alt', 'Control', 'Meta', 'Shift'].includes(e.key)) {\r\n            return;\r\n        }\r\n        // Don't check key if focus is in a prohibited place\r\n        if ((!options.allowInInput) && isInput(document.activeElement)) {\r\n            return;\r\n        }\r\n        if (isProtected(document.activeElement)) {\r\n            return;\r\n        }\r\n        const keyPress = new KeyPress(e);\r\n        keyLog.push(keyPress);\r\n        if (keyLog.length > keyBind.length) {\r\n            keyLog.shift();\r\n        }\r\n        if (keyBind.match(keyLog)) {\r\n            // Clear keyLog and call function\r\n            keyLog.splice(0);\r\n            fn.apply(this, [e, ...otherArgs]);\r\n        }\r\n    };\r\n    return fnWrapper;\r\n};\r\n/**\r\n * Binds an event to a key, key combination, or key sequence.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination, or key sequence to be bound to. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be bound. When called, behaves as though it had been bound by document.addEventListener.\r\n * @param {Object} options - Options to configure behaviour of the key binding.\r\n * @param {boolean} options.allowInInput - If set to true, the key binding will remain active while keyboard focus is in an element that can receive keyboard input, such as <input type=\"text\">.\r\n *\r\n * @return {void}\r\n */\r\nconst bind = (keyString, fn, options) => {\r\n    if (!bindings.has(keyString)) {\r\n        bindings.set(keyString, new Map());\r\n    }\r\n    const keyStringBindings = bindings.get(keyString);\r\n    if (keyStringBindings.has(fn)) {\r\n        // Do nothing - this binding already exists\r\n        return;\r\n    }\r\n    const fnWrapper = createFnWrapper(keyString, fn, options);\r\n    document.addEventListener('keydown', fnWrapper);\r\n    keyStringBindings.set(fn, fnWrapper);\r\n};\r\n/**\r\n * Unbind an event from a key, key combination, or key sequence.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination, or key sequence to unbind from. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be unbound.\r\n *\r\n * @return {void}\r\n */\r\nconst unbind = (keyString, fn) => {\r\n    const keyStringBindings = bindings.get(keyString);\r\n    if (!keyStringBindings) {\r\n        return;\r\n    }\r\n    const fnWrapper = keyStringBindings.get(fn);\r\n    if (fnWrapper) {\r\n        document.removeEventListener('keydown', fnWrapper);\r\n        keyStringBindings.delete(fn);\r\n    }\r\n};\r\n/**\r\n * Check if a given HTMLElement is able to receive keyboard input.\r\n *\r\n * @param  {Element | null} $element - The element to check. If it is not an\r\n *   HTMLElement, the function will return false.\r\n *\r\n * @return {boolean}\r\n */\r\nconst isInput = function ($element) {\r\n    let isInput = false;\r\n    if ($element instanceof HTMLElement) {\r\n        if ($element instanceof HTMLTextAreaElement || $element instanceof HTMLSelectElement) {\r\n            isInput = true;\r\n        }\r\n        else if ($element instanceof HTMLInputElement) {\r\n            isInput = true;\r\n            const inputType = ($element.type || 'text').toLowerCase();\r\n            if (['button', 'checkbox', 'color', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'].includes(inputType)) {\r\n                isInput = false;\r\n            }\r\n        }\r\n        else if ($element.isContentEditable) {\r\n            isInput = true;\r\n        }\r\n    }\r\n    return isInput;\r\n};\r\n/**\r\n * Check if keyboard input to an HTMLElement should never be tracked.\r\n *\r\n * @param  {Element | null} $element - The element to check. If it is not an\r\n *   HTMLElement, the function will return false.\r\n *\r\n * @return {boolean}\r\n */\r\nconst isProtected = function ($element) {\r\n    let isProtected = false;\r\n    if ($element instanceof HTMLInputElement) {\r\n        const inputType = ($element.type || 'text').toLowerCase();\r\n        if (inputType === 'password') {\r\n            isProtected = true;\r\n        }\r\n    }\r\n    return isProtected;\r\n};\r\nexport { bind, unbind, };\r\n//# sourceMappingURL=keybinding.js.map","/**\n * Check visibility in terms of if an element may be focusable.\n *\n * @param  {Element} $el - The Element to check.\n *\n * @return {boolean}\n */\nfunction visible($el: Element): boolean {\n\t// Check visibility in terms of if an element may be focusable\n\n\tlet isVisible = true;\n\n\tconst style = window.getComputedStyle($el);\n\n\tif (\n\t\t($el instanceof HTMLElement) &&\n\t\t(style.position !== 'fixed') &&\n\t\t!($el instanceof HTMLBodyElement || $el instanceof HTMLHtmlElement)\n\t) {\n\t\t// For HTML elements that aren't fixed position, <body>, or <html>,\n\t\t// their offsetParent will be null if they or an ancestor is display: none;\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n\t\tif ($el.offsetParent === null) {\n\t\t\tisVisible = false;\n\t\t}\n\t} else {\n\t\tconst visibility = style.visibility;\n\t\tconst display = style.display;\n\n\t\tif (display === 'none') {\n\t\t\tisVisible = false;\n\t\t} else if (visibility === 'hidden') {\n\t\t\tisVisible = false;\n\t\t} else {\n\t\t\t// Check if an element is hidden because of an ancestor's style\n\t\t\tfor (let $ancestor = $el.parentElement; !!$ancestor; $ancestor = $el.parentElement) {\n\t\t\t\tconst ancestorStyle = window.getComputedStyle($el);\n\n\t\t\t\t// If a ancestor is display: none, this element is hidden\n\t\t\t\tif (ancestorStyle.display === 'none') {\n\t\t\t\t\tisVisible = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn isVisible;\n}\n\n/**\n * Check if an Element can receive keyboard focus.\n *\n * @param  {Element} $el - The Element to check.\n *\n * @return {boolean}\n */\nfunction focusable($el: Element): boolean {\n\tlet isFocusable = false;\n\n\tif (\n\t\t$el instanceof HTMLElement ||\n\t\t$el instanceof SVGElement\n\t) {\n\t\tif ($el instanceof HTMLElement) {\n\t\t\tif (\n\t\t\t\t$el instanceof HTMLInputElement ||\n\t\t\t\t$el instanceof HTMLSelectElement ||\n\t\t\t\t$el instanceof HTMLTextAreaElement ||\n\t\t\t\t$el instanceof HTMLButtonElement\n\t\t\t) {\n\t\t\t\t// Focus if not disabled\n\t\t\t\tconst isNotDisabled = $el.disabled === false;\n\n\t\t\t\tif (isNotDisabled) {\n\t\t\t\t\tisFocusable = true;\n\t\t\t\t}\n\t\t\t} else if ($el instanceof HTMLObjectElement) {\n\t\t\t\t// Focus if not disabled, but no disabled property\n\t\t\t\tconst isNotDisabled = $el.matches('[disabled]') && !$el.matches('[disabled=\"false\"]');\n\n\t\t\t\tif (isNotDisabled) {\n\t\t\t\t\tisFocusable = true;\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\t$el instanceof HTMLAnchorElement ||\n\t\t\t\t$el instanceof HTMLAreaElement\n\t\t\t) {\n\t\t\t\t// Focus through href attribute\n\t\t\t\tconst hasHrefAttribute = $el.matches('[href]');\n\n\t\t\t\tif (hasHrefAttribute) {\n\t\t\t\t\tisFocusable = true;\n\t\t\t\t}\n\t\t\t} else if ($el.contentEditable === 'true') {\n\t\t\t\t// Focus through contentEditable\n\t\t\t\tisFocusable = true;\n\t\t\t}\n\t\t}\n\n\t\tif ($el.matches('[tabindex]')) {\n\t\t\t// Focus through tabindex attribute\n\t\t\tisFocusable = true;\n\t\t}\n\t}\n\n\tif (isFocusable) {\n\t\tconst isVisible = visible($el);\n\n\t\tif (!isVisible) {\n\t\t\tisFocusable = false;\n\t\t}\n\t}\n\n\treturn isFocusable;\n}\n\n/**\n * Check if an HTMLElement can receive focus by pressing the \"tab\" key.\n *\n * @param  {HTMLElement} $el - The HTMLElement to check.\n *\n * @return {boolean}.\n */\nfunction tabbable($el: HTMLElement): boolean {\n\tlet isTabbable = false;\n\n\tconst isFocusable = focusable($el);\n\tif (isFocusable) {\n\t\t// Can receive focus, therefore tababble unless tabindex=\"-1\"\n\t\tconst untabbableTabIndex = $el.tabIndex === -1;\n\n\t\tisTabbable = !untabbableTabIndex;\n\t}\n\n\treturn isTabbable;\n}\n\nexport {\n\tvisible,\n\tfocusable,\n\ttabbable,\n};\n","import { visible, focusable, tabbable } from './focus-helpers.js';\n\nconst classes = Object.freeze({\n\ttrap: 'js-focus-trap',\n});\n\nconst selectors = Object.freeze({\n\ttrap: `.${classes.trap}`,\n});\n\n// There can only be one\nlet $trap: HTMLElement | null = null;\n\n/*\nAdding these dummy elements is necessary in case the focus trap\nis the first or last tabbable area on the page, in which case\nthe user moving focus may move it out of the DOM and therefore\nwon't be picked up by 'focus' events\n*/\nconst $dummyStart = document.createElement('div');\n$dummyStart.setAttribute('tabindex', '0');\n// <div tabindex=\"0\"></div>\n\nconst $dummyEnd = document.createElement('div');\n$dummyEnd.setAttribute('tabindex', '0');\n// <div tabindex=\"0\"></div>\n\n/**\n * Trap focus within a certain HTMLElement, by detecting when focus would leave\n *   it and forcing it to return. Only one element can trap focus at a time.\n *\n * @param {HTMLElement} $el - The element that should have focus trapped within\n *   it.\n *\n * @throws {Error} - $el must have a parentNode for the focus detection elements\n *   to be inserted before and after it.\n */\nfunction trapFocus($el: HTMLElement): void {\n\t// Remove any existing focus traps\n\tuntrapFocus();\n\n\t// Record current focus trap\n\t$trap = $el;\n\t$trap.classList.add(classes.trap);\n\n\t// Add dummy elements for detecting last tab\n\tlet $parent = $trap.parentNode;\n\tif ($parent) {\n\t\t$parent.insertBefore($dummyStart, $trap);\n\t\t$parent.insertBefore($dummyEnd, $trap.nextSibling);\n\t} else {\n\t\tthrow new Error('Modal: Focus trap element has no parentNode');\n\t}\n\n\tdocument.querySelectorAll('*').forEach((el) => el.addEventListener('focus', _wrapTab));\n};\n\n/**\n * Removes the currently active focus trap, returning focus to where it was\n *   before the trap was created.\n */\nfunction untrapFocus(): void {\n\tif ($trap) {\n\t\tdocument.querySelectorAll('*').forEach((el) => el.removeEventListener('focus', _wrapTab));\n\n\t\t$trap.classList.remove(classes.trap);\n\t\t$trap = null;\n\n\t\t$dummyStart.remove();\n\t\t$dummyEnd.remove();\n\t}\n}\n\n/**\n * Returns focus to the correct position within the focus trap, based on where focus has been moved to.\n *\n * @param {Event} e\n */\nfunction _wrapTab(e: Event): void {\n\tconst $focus = e.target;\n\n\tif (($focus instanceof HTMLElement) && $trap) {\n\t\tconst isInTrap = !!$focus.closest(selectors.trap);\n\n\t\tif (!isInTrap) {\n\t\t\tconst $descendants = $trap.querySelectorAll('*');\n\t\t\tconst $tabbable = Array.prototype.filter.call($descendants, tabbable);\n\n\t\t\tconst afterTrap = $trap.compareDocumentPosition($focus) === Node.DOCUMENT_POSITION_FOLLOWING;\n\n\t\t\tif (afterTrap) {\n\t\t\t\t// Wrap to start\n\t\t\t\t$tabbable[0].focus();\n\t\t\t} else {\n\t\t\t\t// Wrap to end\n\t\t\t\t$tabbable[$tabbable.length-1].focus();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport {\n\ttrapFocus,\n\tuntrapFocus,\n};\n","import * as keys from '@cipscis/keybinding';\nimport { trapFocus, untrapFocus } from './trap-focus.js';\nimport { focusable } from './focus-helpers.js';\n\ninterface ModalCallback {\n\t($modal: Element): void;\n}\n\ninterface ModalInitOptions {\n\tonShow?: ModalCallback,\n\tonHide?: ModalCallback,\n\ttriggerSelector?: string,\n}\n\nconst selectors = {\n\tmodal: '.js-modal',\n\tbody: '.js-modal__body',\n\ttrigger: '.js-modal__trigger',\n\tclose: '.js-modal__close',\n};\n\nconst dataAttributes = Object.freeze({\n\tbodyOpenClass: 'data-modal-body-open-class',\n});\n\nconst classes = Object.freeze({\n\tbodyOpen: 'modal__body-open',\n});\n\n/** The active modal window\n *\n * @type {Element | null} */\nlet $focus: Element | null = null;\n\n/** The element that had focus before opening the currently active modal window\n *\n * @type {HTMLElement | null} */\nlet $active: HTMLElement | null = null;\n\nlet _onShow: ModalCallback | null = null;\nlet _onHide: ModalCallback | null = null;\n\n/**\n * Initialise the Modal module.\n *\n * @param {ModalInitOptions} options - An optional set of options.\n * @param {ModalCallback} [onShow] - A callback for when a modal is shown.\n * @param {ModalCallback} [onHide] - A callback for when a modal is hidden.\n * @param {string} [triggerSelector] - A selector to use for finding modal\n *   trigger elements.\n */\nfunction init(options?: ModalInitOptions): void {\n\toptions = options ?? {};\n\n\tif (options.onShow) {\n\t\t_onShow = options.onShow;\n\t}\n\tif (options.onHide) {\n\t\t_onHide = options.onHide;\n\t}\n\tif (options.triggerSelector) {\n\t\tselectors.trigger = options.triggerSelector;\n\t}\n\n\t_initEvents();\n}\n\n/**\n * Initialise events for the Modal module.\n */\nfunction _initEvents(): void {\n\tdocument.addEventListener('click', _processTriggerClickEvent);\n}\n\n/**\n * Bind events that should be active when a modal is active.\n *\n * @throws {Error} - Modals must contain a body element.\n */\nfunction _bindModalActiveEvents(): void {\n\tkeys.bind('esc', _hide, { allowInInput: true });\n\n\tdocument.addEventListener('click', _hideEvent);\n\tdocument.addEventListener('click', _hideIfBackgroundClickEvent);\n\n\t// $active should never be null here because it's only called immediately after setting $active\n\tconst $activeBody = ($active as HTMLElement).querySelector(selectors.body);\n\tif ($activeBody instanceof HTMLElement) {\n\t\ttrapFocus($activeBody);\n\t} else {\n\t\tthrow new Error('Modal: Could not find body element on active modal.');\n\t}\n}\n\n/**\n * Unbind events that should be active when no modal is active.\n */\nfunction _unbindModalActiveEvents(): void {\n\tkeys.unbind('esc', _hide);\n\n\tdocument.removeEventListener('click', _hideEvent);\n\tdocument.removeEventListener('click', _hideIfBackgroundClickEvent);\n\n\tuntrapFocus();\n}\n\n/**\n * A callback called when a modal trigger is clicked.\n *\n * @param {Event} e\n */\nfunction _processTriggerClickEvent(e: Event): void {\n\tconst $target = e.target;\n\n\tif ($target instanceof HTMLElement) {\n\t\tconst $trigger = $target.closest(selectors.trigger);\n\t\tif ($trigger instanceof HTMLElement) {\n\t\t\te.preventDefault();\n\n\t\t\tconst targetId = _getTargetId($trigger);\n\n\t\t\tif (targetId) {\n\t\t\t\t_showById(targetId);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Gets the ID of a modal from a trigger element, looking first at its href and then at its aria-controls attribute.\n *\n * @param  {HTMLElement} $trigger - A modal trigger element.\n *\n * @return {string} The ID of the modal this trigger activates.\n */\nfunction _getTargetId($trigger: HTMLElement): string | null {\n\tlet targetId = $trigger.getAttribute('href');\n\n\tif (targetId && /^#/.test(targetId) === true) {\n\t\ttargetId = targetId.substring(1);\n\t} else {\n\t\ttargetId = $trigger.getAttribute('aria-controls');\n\t}\n\n\treturn targetId;\n}\n\n/**\n * A callback called when the user clicks outside the active modal, which hides the modal.\n *\n * @param {Event} e\n */\nfunction _hideIfBackgroundClickEvent(e: Event): void {\n\tconst $this = e.target;\n\n\tif ($this instanceof HTMLElement) {\n\t\tif ($this.closest(selectors.body)) {\n\t\t\t// Click was within the modal popup, so ignore it\n\t\t\treturn;\n\t\t} else if ($this.closest(selectors.trigger)) {\n\t\t\t// Click was within the trigger, so ignore it\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Click was outside the modal popup, so close it\n\t\t\t_hide();\n\t\t}\n\t}\n}\n\n/**\n * Show a modal with a given ID.\n *\n * @param {string} id - The ID to use to find the modal to show.\n */\nfunction _showById(id: string): void {\n\tconst $modal = document.getElementById(id);\n\n\tif ($modal) {\n\t\t_show($modal);\n\t}\n}\n\n/**\n * Show a given modal element.\n *\n * @param {HTMLElement} $modal - The modal to show.\n */\nfunction _show($modal: HTMLElement): void {\n\tif ($modal === $active) {\n\t\t// Do nothing if the modal is already open\n\t\treturn;\n\t}\n\n\tif ($active) {\n\t\t// If there's already an active modal window,\n\t\t// keep remembering the same $focus element\n\t\t_hide();\n\t}\n\n\t$focus = document.activeElement;\n\t$active = $modal;\n\n\t$modal.setAttribute('aria-hidden', 'false');\n\n\tconst bodyOpenClass = _getBodyOpenClass($modal);\n\t(document.querySelector('body') as HTMLElement).classList.add(bodyOpenClass);\n\n\t// Move focus within modal window\n\tconst $focusable = _getFocusable();\n\tif ($focusable && $focusable.length) {\n\t\t$focusable[0].focus();\n\t}\n\n\t_bindModalActiveEvents();\n\n\tif (_onShow) {\n\t\t_onShow($modal);\n\t}\n}\n\n/**\n * A callback called when a modal is hidden.\n *\n * @param {Event} e\n */\nfunction _hideEvent(e: Event): void {\n\tconst $target = e.target;\n\n\tif ($target instanceof HTMLElement) {\n\t\tif ($target.closest(selectors.close)) {\n\t\t\te.preventDefault();\n\t\t\t_hide();\n\t\t}\n\t}\n}\n\n/**\n * Hide the currently active modal.\n */\nfunction _hide(): void {\n\tif ($active) {\n\t\tconst $modal = $active;\n\t\t$modal.setAttribute('aria-hidden', 'true');\n\n\t\tconst bodyOpenClass = _getBodyOpenClass($modal);\n\t\t(document.querySelector('body') as HTMLElement).classList.remove(bodyOpenClass);\n\n\t\t_unbindModalActiveEvents();\n\n\t\t// Return focus where it was\n\t\tif ($focus) {\n\t\t\tif (\n\t\t\t\t$focus instanceof HTMLElement\n\t\t\t) {\n\t\t\t\t$focus.focus();\n\t\t\t}\n\t\t}\n\n\t\t$active = null;\n\t\t$focus = null;\n\n\t\tif (_onHide) {\n\t\t\t_onHide($modal);\n\t\t}\n\t}\n}\n\n/**\n * Get the class that should be applied to the <body> element while a given modal is open.\n *\n * @param  {HTMLElement} $modal - The modal that will be open.\n *\n * @return {string} The class to be applied to the <body> element.\n */\nfunction _getBodyOpenClass($modal: HTMLElement): string {\n\tconst bodyOpenClass = $modal.getAttribute(dataAttributes.bodyOpenClass) || classes.bodyOpen;\n\n\treturn bodyOpenClass;\n}\n\n/**\n * Get all elements within a given modal element, or the currently active one, that can receive keyboard focus.\n *\n * @param {(HTMLElement} $modal - The relevant modal element.\n */\nfunction _getFocusable($modal: HTMLElement = $active as HTMLElement): (HTMLElement)[] | undefined {\n\t// $active always set because this is only called after setting it\n\tconst $body = $modal.querySelector(selectors.body);\n\n\tif ($body instanceof HTMLElement) {\n\t\tconst $descendents = $body.querySelectorAll('*');\n\t\tconst $focusable: (HTMLElement)[] = Array.prototype.filter.call($descendents, focusable);\n\n\t\tif (focusable($body)) {\n\t\t\t$focusable.unshift($body);\n\t\t}\n\n\t\treturn $focusable;\n\t} else {\n\t\tthrow new Error('Modal: Could not find body element on active modal.');\n\t}\n}\n\n/**\n * Show a modal with a given ID.\n *\n * @param {string} id - The ID to use to find the modal to show.\n */\nfunction show(id: string): void {\n\treturn _showById(id);\n}\n\n/**\n * Hide the currently active modal.\n */\nfunction hide(): void {\n\treturn _hide();\n};\n\nexport {\n\tinit,\n\tshow,\n\thide,\n};\n","// Using import from '/filename', Webpack will\n// bundle files from outside the docs directory\n// even though it is the root for the server\n// both locally and on GitHub Pages\n\nimport * as modal from '@cipscis/modal';\nimport * as keys from '@cipscis/keybinding';\n\nmodal.init({\n\tonShow: ($modal) => console.log('Show', $modal),\n\tonHide: ($modal) => console.log('Hide', $modal),\n});\n\nconst selectors = Object.freeze({\n\tshow: '.js-example__show',\n\thide: '.js-example__hide',\n});\n\nconst showExample = (e: Event) => {\n\te.stopPropagation();\n\n\tmodal.show('modal-show-example');\n};\ndocument.querySelectorAll(selectors.show).forEach(($el) => $el.addEventListener('click', showExample));\nkeys.bind('B', showExample);\nkeys.bind('B', showExample);\n\ndocument.querySelectorAll(selectors.hide).forEach(($el) => $el.addEventListener('click', modal.hide));\n"],"names":["KeyBind","Array","constructor","bindingString","RangeError","super","bindings","trim","split","binding","this","push","toString","join","match","keyPresses","length","i","keyPress","entries","keyBind","Patterns","Object","freeze","alt","ctrl","shift","Aliases","Map","KeyPress","key","modifiers","options","altKey","ctrlKey","metaKey","shiftKey","keyString","requiredModifiers","modifier","test","replace","toLowerCase","get","defaults","allowInInput","createFnWrapper","fn","opts","assign","keyLog","e","otherArgs","includes","isInput","document","activeElement","isProtected","splice","apply","bind","has","set","keyStringBindings","fnWrapper","addEventListener","$element","HTMLElement","HTMLTextAreaElement","HTMLSelectElement","HTMLInputElement","inputType","type","isContentEditable","focusable","$el","isFocusable","SVGElement","HTMLButtonElement","disabled","HTMLObjectElement","matches","HTMLAnchorElement","HTMLAreaElement","contentEditable","isVisible","style","window","getComputedStyle","position","HTMLBodyElement","HTMLHtmlElement","offsetParent","visibility","display","$ancestor","parentElement","visible","tabbable","isTabbable","tabIndex","classes","trap","selectors","$trap","$dummyStart","createElement","setAttribute","$dummyEnd","untrapFocus","querySelectorAll","forEach","el","removeEventListener","_wrapTab","classList","remove","$focus","target","closest","$descendants","$tabbable","prototype","filter","call","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","focus","modal","body","trigger","close","dataAttributes","bodyOpenClass","bodyOpen","$active","_onShow","_onHide","_hideIfBackgroundClickEvent","$this","_hide","_showById","id","$modal","getElementById","_getBodyOpenClass","querySelector","add","$focusable","$body","$descendents","unshift","Error","_getFocusable","_hideEvent","$activeBody","$parent","parentNode","insertBefore","nextSibling","trapFocus","_bindModalActiveEvents","_show","$target","preventDefault","delete","getAttribute","hide","onShow","console","log","onHide","triggerSelector","$trigger","targetId","substring","_getTargetId","show","showExample","stopPropagation"],"sourceRoot":""}